package server.gcm;

import java.io.IOException;
import java.text.ParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.net.ssl.SSLSocketFactory;

import org.jivesoftware.smack.ConnectionConfiguration;
import org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;
import org.jivesoftware.smack.ConnectionListener;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.SmackException.NotConnectedException;
import org.jivesoftware.smack.StanzaListener;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketTypeFilter;
import org.jivesoftware.smack.packet.DefaultExtensionElement;
import org.jivesoftware.smack.packet.ExtensionElement;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Stanza;
import org.jivesoftware.smack.provider.ExtensionElementProvider;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.roster.Roster;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration;
import org.jivesoftware.smack.util.StringUtils;
import org.json.simple.JSONValue;
import org.xmlpull.v1.XmlPullParser;

/**
 * Sample Smack implementation of a client for GCM Cloud Connection Server. 
 * Most of it has been taken more or less verbatim from Googles 
 * documentation: http://developer.android.com/google/gcm/ccs.html
 * <br>
 * But some additions have been made. Bigger changes are annotated like that:
 * "/// new".
 * <br>
 * Those changes have to do with parsing certain type of messages
 * as well as with sending messages to a list of recipients. The original code
 * only covers sending one message to exactly one recipient.
 */
public class GCMManager {

    public static final Logger logger = Logger.getLogger(GCMManager.class.getName());

    public static final String GCM_SERVER = "gcm.googleapis.com";
    public static final int GCM_PORT = 5235;

    public static final String GCM_ELEMENT_NAME = "gcm";
    public static final String GCM_NAMESPACE = "google:mobile:data";

    static Random random = new Random();
    XMPPTCPConnection connection;
    ConnectionConfiguration config;

    /// new: some additional instance and class members
    private static GCMManager sInstance = null;
    private String mApiKey = null;
    private String mProjectId = null;
    private boolean mDebuggable = false;

  static {

      ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE, new  ExtensionElementProvider<ExtensionElement>() {
          @Override
          public DefaultExtensionElement parse(XmlPullParser parser,int initialDepth) throws org.xmlpull.v1.XmlPullParserException,
          IOException {
              String json = parser.nextText();
              return new GcmPacketExtension(json);
          }
      });
  }
    
  
  public GCMManager(String projectId, String apiKey, boolean debuggable) {
      mApiKey = apiKey;
      mProjectId = projectId;
      mDebuggable = debuggable;
  }
  
//
//    public static GCMManager getInstance() {
//        if (sInstance == null) {
//            throw new IllegalStateException("You have to prepare the client first");
//        }
//        return sInstance;
//    }
    
//    public static GCMManager prepareClient(String projectId, String apiKey, boolean debuggable) {
//        synchronized(GCMManager.class) {
//            if (sInstance == null) {
//                sInstance = new GCMManager(projectId, apiKey, debuggable);
//            }
//        }
//        return sInstance;
//    }



    /**
     * Returns a random message id to uniquely identify a message.
     *
     * <p>
     * Note: This is generated by a pseudo random number generator for
     * illustration purpose, and is not guaranteed to be unique.
     *
     */
    public String getRandomMessageId() {
        return "m-" + Long.toString(random.nextLong());
    }

    /**
     * Sends a downstream GCM message.
     */
    public void send(String jsonRequest) {
    	 Stanza request = new GcmPacketExtension(jsonRequest).toPacket();
    	 try {
			connection.sendStanza(request);
		} catch (NotConnectedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }


    /**
     * Creates a JSON encoded GCM message.
     *
     * @param to RegistrationId of the target device (Required).
     * @param messageId Unique messageId for which CCS will send an "ack/nack"
     * (Required).
     * @param payload Message content intended for the application. (Optional).
     * @param collapseKey GCM collapse_key parameter (Optional).
     * @param timeToLive GCM time_to_live parameter (Optional).
     * @param delayWhileIdle GCM delay_while_idle parameter (Optional).
     * @return JSON encoded GCM message.
     */
    public static String createJsonMessage(String to, String messageId, Map<String, Object> payload,
            String collapseKey, Long timeToLive, Boolean delayWhileIdle) {
        return createJsonMessage(createAttributeMap(to, messageId, payload,
                collapseKey, timeToLive, delayWhileIdle));
    }
    
    public static String createJsonMessage(Map map) {
        return JSONValue.toJSONString(map);
    }

    public static Map createAttributeMap(String to, String messageId, Map<String, Object> payload,
            String collapseKey, Long timeToLive, Boolean delayWhileIdle) {
        Map<String, Object> message = new HashMap<String, Object>();
        if (to != null) {
            message.put("to", to);
        }
        if (collapseKey != null) {
            message.put("collapse_key", collapseKey);
        }
        if (timeToLive != null) {
            message.put("time_to_live", timeToLive);
        }
        if (delayWhileIdle != null && delayWhileIdle) {
            message.put("delay_while_idle", true);
        }
        message.put("message_id", messageId);
        message.put("data", payload);
        return message;
    }

    /**
     * Connects to GCM Cloud Connection Server using the supplied credentials.
     * @throws XMPPException
     */
    @SuppressWarnings("deprecation")
	public void connect() throws XMPPException {
    	XMPPTCPConnectionConfiguration config =
		XMPPTCPConnectionConfiguration.builder()
		.setServiceName(GCM_SERVER)
	     .setHost(GCM_SERVER)
	     .setCompressionEnabled(false)
	     .setPort(GCM_PORT)
	     .setConnectTimeout(30000)
	     .setSecurityMode(SecurityMode.disabled)
	     .setSendPresence(false)
	     .setSocketFactory(SSLSocketFactory.getDefault())
	    .build();
//    	    
//        config = ConnectionConfiguration.Builder<Builder<B,C>, ConnectionConfiguration> (GCM_SERVER, GCM_PORT);
//        config.setSecurityMode(SecurityMode.enabled);
//        config.setReconnectionAllowed(true);
//        config.setRosterLoadedAtLogin(false);
//        config.setSendPresence(false);
//        config.setSocketFactory(SSLSocketFactory.getDefault());

        // NOTE: Set to true to launch a window with information about packets sent and received
//        config.setDebuggerEnabled(mDebuggable);

        // -Dsmack.debugEnabled=true
//        XMPPConnection.DEBUG_ENABLED = true;

      connection = new XMPPTCPConnection(config);
      
      //disable Roster as I don't think this is supported by GCM
      Roster roster = Roster.getInstanceFor(connection);
      roster.setRosterLoadedAtLogin(false);

      logger.info("Connecting...");
      try {
		connection.connect();
	} catch (SmackException | IOException e1) {
		// TODO Auto-generated catch block
		e1.printStackTrace();
	}
    	
//        connection = new XMPPConnection(config);
//        connection.connect();

        connection.addConnectionListener(new LoggingConnectionListener());
          		    
        

        // Handle incoming packets
        connection.addPacketListener(new PacketListener() {

            @Override
            public void processPacket(Stanza packet) {
            	MessageHandler handler = new MessageHandler();
                logger.log(Level.INFO, "Received: " + packet.toXML());
                Message incomingMessage = (Message) packet;
                GcmPacketExtension gcmPacket = (GcmPacketExtension) incomingMessage.getExtension(GCM_NAMESPACE);
                String json = gcmPacket.getJson();
                try {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> jsonMap = (Map<String, Object>) JSONValue.parseWithException(json);
                    handler.handleMessage(jsonMap);
                } catch (ParseException e) {
                    logger.log(Level.SEVERE, "Error parsing JSON " + json, e);
                } catch (Exception e) {
                    logger.log(Level.SEVERE, "Couldn't send echo.", e);
                } 
            }
        }, new PacketTypeFilter(Message.class));

        // Log all outgoing packets
        connection.addPacketInterceptor(new StanzaListener() {
			
			@Override
			public void processPacket(Stanza arg0) throws NotConnectedException {
                logger.log(Level.INFO, "Sent: {0}", arg0.toXML());
			}
		}, new PacketTypeFilter(Message.class));

        try {
			connection.login(mProjectId + "@gcm.googleapis.com", mApiKey);
		} catch (SmackException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        logger.log(Level.INFO, "logged in: " + mProjectId);
    }

    

	private static final class LoggingConnectionListener implements ConnectionListener {

		@Override
		public void connected(XMPPConnection xmppConnection) {
			logger.info("Connected.");
		}

		@Override
		public void reconnectionSuccessful() {
			logger.info("Reconnecting..");
		}

		@Override
		public void reconnectionFailed(Exception e) {
			logger.log(Level.INFO, "Reconnection failed.. ", e);
		}

		@Override
		public void reconnectingIn(int seconds) {
			logger.log(Level.INFO, "Reconnecting in %d secs", seconds);
		}

		@Override
		public void connectionClosedOnError(Exception e) {
			logger.info("Connection closed on error.");
		}

		@Override
		public void connectionClosed() {
			logger.info("Connection closed.");
		}

		@Override
		public void authenticated(XMPPConnection arg0, boolean arg1) {
			// TODO Auto-generated method stub

		}
	}
	
	/**
	 * XMPP Packet Extension for GCM Cloud Connection Server.
	 */
	private static final class GcmPacketExtension extends DefaultExtensionElement {

		private final String json;

		public GcmPacketExtension(String json) {
			super(GCM_ELEMENT_NAME, GCM_NAMESPACE);
			this.json = json;
		}

		public String getJson() {
			return json;
		}

		@Override
		public String toXML() {
			return String.format("<%s xmlns=\"%s\">%s</%s>", GCM_ELEMENT_NAME, GCM_NAMESPACE, StringUtils.escapeForXML(json), GCM_ELEMENT_NAME);
		}

		public Stanza toPacket() {
			Message message = new Message();
			message.addExtension(this);
			return message;
		}
	}
	
    




    
  

}


